class DSU{
    public:
    vector<int>size,parent;
    DSU(int n){
   size.resize(n+1);
   parent.resize(n+1);
   for(int i=0;i<n;i++){
    parent[i]=i;
    size[i]=1;
   }
    }
    int findUlp(int node){
        if(parent[node]==node)return node;
        return parent[node]=findUlp(parent[node]);
    }
    void unionBySize(int u,int v){
        int pu=findUlp(u);
        int pv=findUlp(v);
        if(pu==pv)return;
        if(size[pu]>size[pv]){
            size[pu]+=size[pv];
            parent[pv]=pu;
        }else{
            size[pv]+=size[pu];
            parent[pu]=pv;
        }
    }
};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        DSU ds(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i!=j&&graph[i][j]){
                     ds.unionBySize(i,j);
                }
            }
        }
        sort(initial.begin(),initial.end());
        unordered_map<int,int>mp;
        for(int i=0;i<initial.size();i++){
            mp[ds.findUlp(initial[i])]++;
        }
        int ans=0,count=0;
        for(int i=0;i<initial.size();i++){
            if(mp[ds.findUlp(initial[i])]==1){
                if(ds.size[ds.findUlp(initial[i])]>count){
                    count=ds.size[ds.findUlp(initial[i])];
                    ans=i;
                }
            }
            
        }
        return initial[ans];
        
    }
};